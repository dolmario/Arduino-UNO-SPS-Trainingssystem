#!/usr/bin/env python3
import sys
import yaml
from pathlib import Path
from parser_logo import parse_logo_csv, parse_logo_xml, load_hardware_profile

TEMPLATE_HEADER = r"""
/*
 * Auto-generated by generator_arduino.py
 * Target: Arduino UNO (arduino:avr:uno)
 *
 * Unterstützte Blöcke: AND, OR, NOT, XOR, NAND, NOR,
 * SR, RS, R_TRIG, F_TRIG,
 * TON, TOF,
 * CTU, CTD,
 * GT, LT, GE, LE, EQ, NE,
 * ADD, SUB, MUL, DIV,
 * MOVE
 *
 * Hardware: Relais Q1..Q8, MOSFET PWM (AO*_PWM),
 * DS18B20, Buzzer, MQ-2/3/7/135 (analog), KY-040, 7-Segment BCD.
 */

#include <Arduino.h>

// ----- Optional Sensors / HW -----
#ifdef USE_ONEWIRE
  #include <OneWire.h>
  #include <DallasTemperature.h>
#endif

#ifdef USE_ENCODER
  #include <Encoder.h>
#endif

// ---- Konfiguration (aus YAML injiziert) ----
"""

TEMPLATE_FOOTER = r"""
// ======= Hilfsfunktionen =======

int toBool(int v){ return v ? HIGH : LOW; }
int fromBool(int v){ return (v==HIGH)?1:0; }

// ======= LOGO-Laufzeit =======

struct TON {
  unsigned long pt_ms;
  bool q;
  unsigned long start;
  TON() : pt_ms(0), q(false), start(0) {}
  bool eval(bool in) {
    if (!in){ q=false; start=0; return q; }
    if (start==0) start=millis();
    if ((millis()-start)>=pt_ms) q=true;
    return q;
  }
};

struct TOF {
  unsigned long pt_ms;
  bool q;
  unsigned long off;
  TOF(): pt_ms(0), q(false), off(0) {}
  bool eval(bool in){
    if (in){ q=true; off=0; return q; }
    if (q && off==0) off=millis();
    if (q && (millis()-off)>=pt_ms) q=false;
    return q;
  }
};

struct R_TRIG { bool last=false; bool eval(bool in){ bool r=in && !last; last=in; return r; } };
struct F_TRIG { bool last=false; bool eval(bool in){ bool f=!in && last; last=in; return f; } };

struct CTU {
  long cv=0; long pv=1; bool q=false;
  long eval(bool cu, bool r){
    if (r){ cv=0; q=false; return cv; }
    if (cu){ cv++; if (cv>=pv) q=true; }
    return cv;
  }
};

struct CTD {
  long cv=0; long pv=1; bool q=false;
  long eval(bool cd, bool l){
    if (l){ cv=pv; q=true; return cv; }
    if (cd){ cv--; if (cv<=0) q=false; }
    return cv;
  }
};

// ======= Variablen (werden im Generator gefüllt) =======
"""

def load_hw():
    try:
        return load_hardware_profile()
    except Exception:
        return {'pins': {}, 'flags': {}}

def parse_blocks(in_file):
    suffix = Path(in_file).suffix.lower()
    if suffix == ".xml":
        return parse_logo_xml(in_file)
    return parse_logo_csv(in_file)

def parse_time_param(p):
    # LOGO Zeitformat T#5s, T#200ms etc.
    if not p or 'T#' not in p:
        return 0
    t = p.strip().upper().replace('T#', '')
    if t.endswith('MS'):
        return int(t[:-2])
    if t.endswith('S'):
        return int(float(t[:-1])*1000)
    if t.endswith('M'):
        return int(float(t[:-1])*60000)
    if t.endswith('H'):
        return int(float(t[:-1])*3600000)
    try:
        return int(t)
    except:
        return 0

def emit_pins(hw):
    pins = hw.get('pins', {})
    flags = hw.get('flags', {})
    lines = []
    lines.append("// Pins aus hardware_profile.yaml (falls vorhanden)")
    for k,v in pins.items():
        if isinstance(v, str) and v.upper().startswith('A'):
            # analog als Nummer abbilden
            anum = 14 + int(v[1:])  # A0=14 beim UNO
            lines.append(f"const uint8_t PIN_{k} = {anum}; // {v}")
        else:
            lines.append(f"const uint8_t PIN_{k} = {v};")
    lines.append(f"const bool RELAYS_ACTIVE_LOW = {'true' if flags.get('relays_active_low', False) else 'false'};")
    lines.append(f"const bool MOSFET_ACTIVE_LOW = {'true' if flags.get('mosfet_active_low', False) else 'false'};")
    return "\n".join(lines) + "\n"

def needs(libflag, hw):
    pins = hw.get('pins', {})
    if libflag == "USE_ONEWIRE":
        return "TEMP_DS18B20" in pins
    if libflag == "USE_ENCODER":
        return "ENC_A" in pins and "ENC_B" in pins
    return False

def emit_macros(hw):
    macros = []
    if needs("USE_ONEWIRE", hw): macros.append("#define USE_ONEWIRE 1")
    if needs("USE_ENCODER", hw): macros.append("#define USE_ENCODER 1")
    return ("\n".join(macros) + "\n") if macros else "\n"

def emit_setup(hw):
    pins = hw.get('pins', {})
    lines = []
    lines.append("void setup(){")
    lines.append("  // IO Richtungen")
    # Inputs (I1..I8?) als INPUT_PULLUP – Trainingsaufbau
    for name,p in pins.items():
        if name.startswith('I'):
            lines.append(f"  pinMode(PIN_{name}, INPUT_PULLUP);")
    # Outputs Q1..Q8 Relais
    for q in [k for k in pins.keys() if k.startswith('Q')]:
        lines.append(f"  pinMode(PIN_{q}, OUTPUT); digitalWrite(PIN_{q}, RELAYS_ACTIVE_LOW?HIGH:LOW);")
    # PWM/MOSFET
    for ao in [k for k in pins.keys() if k.startswith('AO')]:
        lines.append(f"  pinMode(PIN_{ao}, OUTPUT); analogWrite(PIN_{ao}, MOSFET_ACTIVE_LOW?255:0);")
    # Buzzer
    if "BUZZER" in pins:
        lines.append("  pinMode(PIN_BUZZER, OUTPUT); digitalWrite(PIN_BUZZER, LOW);")
    # 7-Segment BCD
    for bcd in ["BCD_A","BCD_B","BCD_C","BCD_D"]:
        if bcd in pins:
            lines.append(f"  pinMode(PIN_{bcd}, OUTPUT); digitalWrite(PIN_{bcd}, LOW);")
    # Encoder
    if needs("USE_ENCODER", hw):
        lines.append("  // Encoder initialisiert in globalem Bereich")
    # DS18B20
    if needs("USE_ONEWIRE", hw):
        lines.append("  oneWire.begin(PIN_TEMP_DS18B20);")
        lines.append("  sensors.setOneWire(&oneWire); sensors.begin();")
    lines.append("  Serial.begin(115200);")
    lines.append("}")
    return "\n".join(lines) + "\n"

def emit_globals(hw):
    lines = []
    if needs("USE_ONEWIRE", hw):
        lines.append("OneWire oneWire(PIN_TEMP_DS18B20);")
        lines.append("DallasTemperature sensors(&oneWire);")
        lines.append("float tempC = 0.0;")
    if needs("USE_ENCODER", hw):
        lines.append("Encoder enc(PIN_ENC_A, PIN_ENC_B); long encPos=0;")
    # Analog MQ Sensoren werden einfach über AI* gelesen -> keine Lib nötig.
    return "\n".join(lines) + "\n"

def emit_bcd_write():
    return r"""
void bcdWrite(uint8_t val){
  // erwartet 0..15
  digitalWrite(PIN_BCD_A, (val>>0)&1);
  digitalWrite(PIN_BCD_B, (val>>1)&1);
  digitalWrite(PIN_BCD_C, (val>>2)&1);
  digitalWrite(PIN_BCD_D, (val>>3)&1);
}
"""

def emit_loop_header():
    return "void loop(){\n"

def emit_loop_footer():
    return "  delay(5);\n}\n"

def gen_from_blocks(blocks, hw):
    """
    Einfache Verdrahtung:
    - Eingänge I*, AI* werden gelesen
    - Merker M* sind bool-Variablen
    - Ausgänge Q*/AO* werden gesetzt
    - Blockliste wird seriell ausgewertet (Datenfluss)
    """
    lines = []
    # Deklarationen
    inputs = sorted({i for b in blocks for i in b['inputs'] if i})
    outputs = sorted({b['output'] for b in blocks if b.get('output')})
    merkers = sorted({s for s in inputs+outputs if s and s.startswith('M')})
    # Variablen
    for m in merkers:
        lines.append(f"static bool {m}=false;")
    # Timer/Trig/Ctr Instanzen anhand der Blöcke
    ton_idx = tof_idx = r_idx = f_idx = ctu_idx = ctd_idx = 0

    # Zuordnung Block -> interne Namen
    inst_map = {}

    # Eingänge/Analoge lesen
    lines.append("\n  // Eingänge lesen")
    for i in sorted({i for i in inputs if i and i.startswith('I')}):
        pin = f"PIN_{i}"
        lines.append(f"  bool {i}_val = (digitalRead({pin})==HIGH);")
    for ai in sorted({i for i in inputs if i and i.startswith('AI')}):
        pin = f"PIN_{ai}"
        lines.append(f"  int {ai}_raw = analogRead({pin});")

    # DS18B20 optional
    lines.append("")
    lines.append("  // Optional: Temperatursensor")
    if needs("USE_ONEWIRE", hw):
        lines.append("  sensors.requestTemperatures();")
        lines.append("  tempC = sensors.getTempCByIndex(0);")

    lines.append("\n  // Blöcke auswerten")
    for b in blocks:
        t = b['type']
        bid = b['id']
        ins = [f"({s}_val)" if s.startswith('I') else
               f"({s})" if s.startswith('M') else
               f"({s}_raw)" if s.startswith('AI') else
               "0"
               for s in b['inputs']]
        out = b['output']

        if t in {"AND","OR","XOR","NAND","NOR","NOT"}:
            expr = ""
            if t=="AND": expr = " && ".join(ins) if ins else "0"
            elif t=="OR": expr = " || ".join(ins) if ins else "0"
            elif t=="XOR": expr = " ^ ".join([f"({x})" for x in ins]) if ins else "0"
            elif t=="NAND": expr = "!(" + (" && ".join(ins) if ins else "0") + ")"
            elif t=="NOR": expr = "!(" + (" || ".join(ins) if ins else "0") + ")"
            elif t=="NOT": expr = "!(" + (ins[0] if ins else "0") + ")"
            if out.startswith('M'):
                lines.append(f"  {out} = ({expr}); // {bid} {t}")
            elif out.startswith('Q'):
                pin = f"PIN_{out}"
                lines.append(f"  digitalWrite({pin}, ({expr}) ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW)); // {bid} {t}")
            elif out.startswith('AO'):
                pin = f"PIN_{out}"
                lines.append(f"  analogWrite({pin}, ({expr}) ? (MOSFET_ACTIVE_LOW?0:255):(MOSFET_ACTIVE_LOW?255:0)); // {bid} {t}")

        elif t in {"SR","RS"}:
            s = ins[0] if len(ins)>0 else "0"
            r = ins[1] if len(ins)>1 else "0"
            if out.startswith('M'):
                if t=="SR":
                    lines.append(f"  if ({r}) {out}=false; if ({s}) {out}=true; // {bid} SR")
                else:
                    lines.append(f"  if ({s}) {out}=true; if ({r}) {out}=false; // {bid} RS")
            elif out.startswith('Q'):
                pin = f"PIN_{out}"
                var = f"m_{out}"
                lines.append(f"  static bool {var}=false; if ({r}) {var}=false; if ({s}) {var}=true;")
                lines.append(f"  digitalWrite({pin}, {var} ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW)); // {bid} {t}")

        elif t in {"R_TRIG","F_TRIG"}:
            if t=="R_TRIG":
                name=f"_rt{r_idx}"; r_idx+=1
                lines.append(f"  static R_TRIG {name}; bool {bid}_q = {name}.eval({ins[0] if ins else '0'});")
            else:
                name=f"_ft{f_idx}"; f_idx+=1
                lines.append(f"  static F_TRIG {name}; bool {bid}_q = {name}.eval({ins[0] if ins else '0'});")
            if out.startswith('M'): lines.append(f"  {out} = {bid}_q;")
            elif out.startswith('Q'):
                pin=f"PIN_{out}"
                lines.append(f"  digitalWrite({pin}, {bid}_q ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW));")

        elif t in {"TON","TOF"}:
            pt_ms = parse_time_param(b.get('param',''))
            if t=="TON":
                name=f"_ton{ton_idx}"; ton_idx+=1
                lines.append(f"  static TON {name}; {name}.pt_ms={pt_ms}; bool {bid}_q = {name}.eval({ins[0] if ins else '0'});")
            else:
                name=f"_tof{tof_idx}"; tof_idx+=1
                lines.append(f"  static TOF {name}; {name}.pt_ms={pt_ms}; bool {bid}_q = {name}.eval({ins[0] if ins else '0'});")
            if out.startswith('M'): lines.append(f"  {out} = {bid}_q;")
            elif out.startswith('Q'):
                pin=f"PIN_{out}"
                lines.append(f"  digitalWrite({pin}, {bid}_q ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW));")

        elif t in {"GT","LT","GE","LE","EQ","NE"}:
            a = ins[0] if len(ins)>0 else "0"
            b2 = ins[1] if len(ins)>1 else "0"
            op = {"GT":">","LT":"<","GE":">=","LE":"<=","EQ":"==","NE":"!="}[t]
            expr = f"({a}) {op} ({b2})"
            target = out
            if target.startswith('M'):
                lines.append(f"  {target} = ({expr}); // {bid} {t}")
            elif target.startswith('Q'):
                pin=f"PIN_{target}"
                lines.append(f"  digitalWrite({pin}, ({expr}) ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW));")

        elif t in {"ADD","SUB","MUL","DIV","MOVE"}:
            a = ins[0] if len(ins)>0 else "0"
            b2 = ins[1] if len(ins)>1 else "0"
            expr = {"ADD":f"({a})+({b2})",
                    "SUB":f"({a})-({b2})",
                    "MUL":f"({a})*({b2})",
                    "DIV":f"(({b2})!=0?({a})/({b2}):0)",
                    "MOVE":f"({a})"}[t]
            # Nur AO*/AI*/Merker sinnvoll als Variable; Q ist bool
            if out.startswith('M'):
                lines.append(f"  {out} = ({expr}) != 0; // {bid} {t} -> bool")
            elif out.startswith('AO'):
                pin=f"PIN_{out}"
                lines.append(f"  {{ long __v = ({expr}); if (__v<0) __v=0; if (__v>255) __v=255; analogWrite({pin}, MOSFET_ACTIVE_LOW?(255-__v):__v); }} // {bid} {t}")
            elif out.startswith('Q'):
                pin=f"PIN_{out}"
                lines.append(f"  digitalWrite({pin}, (({expr})!=0) ? (RELAYS_ACTIVE_LOW?LOW:HIGH):(RELAYS_ACTIVE_LOW?HIGH:LOW)); // {bid} {t}")

        elif t in {"CTU","CTD"}:
            if t=="CTU":
                name=f"_ctu{ctu_idx}"; ctu_idx+=1
                lines.append(f"  static CTU {name}; {name}.pv=10; long {bid}_cv = {name}.eval({ins[0] if ins else '0'}, {ins[1] if len(ins)>1 else '0'});")
            else:
                name=f"_ctd{ctd_idx}"; ctd_idx+=1
                lines.append(f"  static CTD {name}; {name}.pv=10; long {bid}_cv = {name}.eval({ins[0] if ins else '0'}, {ins[1] if len(ins)>1 else '0'});")
            if out.startswith('M'):
                lines.append(f"  {out} = {name}.q;")

        else:
            lines.append(f"  // Block {bid} Typ {t} noch nicht implementiert – wird übersprungen")

        # 7-Segment BCD: falls jemand AO auf 0..15 führt und BCD vorhanden ist
        if out.startswith('AO') and all(k in hw.get('pins',{}) for k in ["BCD_A","BCD_B","BCD_C","BCD_D"]):
            lines.append("  // Optional: AO → BCD (niedrige 4 Bit)")
            lines.append("  // Hinweis: Für echte BCD-Gabe eigener Block sinnvoller.")
    return "\n".join(lines) + "\n"

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 generator_arduino.py <projekt.csv|projekt.xml>")
        sys.exit(1)
    in_file = sys.argv[1]
    blocks = parse_blocks(in_file)
    hw = load_hw()

    # Ausgaben
    # Macros
    print(emit_macros(hw), end="")
    # Header + Pins
    print(TEMPLATE_HEADER, end="")
    print(emit_pins(hw))
    print(TEMPLATE_FOOTER, end="")
    # Globals
    print(emit_globals(hw))
    # Utilities
    if all(k in hw.get('pins',{}) for k in ["BCD_A","BCD_B","BCD_C","BCD_D"]):
        print(emit_bcd_write())
    # Setup
    print(emit_setup(hw))
    # Loop
    print(emit_loop_header())
    print(gen_from_blocks(blocks, hw))
    print(emit_loop_footer())

if __name__ == "__main__":
    main()

